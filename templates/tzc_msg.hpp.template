@###############################################
@#
@# ROS-TZC message source code generation for C++
@#
@# EmPy template for generating tzc_<msg>.hpp files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@###############################################
// Generated by tzc_gencpp from file @(spec.package)/@(spec.short_name).msg
// DO NOT EDIT!

@{
import genmsg.msgs
import gencpp
import tzc_gencpp

cpp_namespace = '::%s::'%(spec.package) # TODO handle nested namespace
cpp_class = '%s'%spec.short_name
cpp_full_name = '::tzc_transport%s%s'%(cpp_namespace,cpp_class)
cpp_msg_definition = gencpp.escape_message_definition(msg_definition)
}@

#ifndef TZC_@(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_HPP
#define TZC_@(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_HPP

@##############################
@# Generic Includes
@##############################

#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <tzc_transport/tzc_topic.hpp>
#include <tzc_transport/tzc_object.hpp>
#include <tzc_transport/tzc_vector.hpp>

@##############################
@# Includes for dependencies
@##############################
@{
for field in spec.parsed_fields():
  if (not field.is_builtin):
    if (field.is_header):
      print('#include <std_msgs/Header.h>')
    else:
      (package, name) = genmsg.names.package_resource_name(field.base_type)
      package = package or spec.package # convert '' to package
      if (tzc_gencpp.use_tzc_type(name, package, msg_context, search_path)):
        print('#include <%s/tzc_%s.hpp>'%(package, name))
      else:
        print('#include <%s/%s.h>'%(package, name))
}@

namespace tzc_transport {
namespace @(spec.package) {

struct @(cpp_class)_ {
@[for field in spec.parsed_fields()]
@{  cpp_type = tzc_gencpp.msg_type_to_cpp(field.type, spec.package, msg_context, search_path)}@
  typedef @(cpp_type) _@(field.name)_type;
  _@(field.name)_type @(field.name);
@[end for]
}; // struct @(cpp_class)_

class @(cpp_class) : public @(cpp_class)_, public BaseMsg {
private:
  // used by publisher, calculate required length of shared memory
  size_t getLength() {
    size_t res = 0;
@{
tzc_gencpp.spec_to_getlength(spec, msg_context, search_path, '', '    ')
}@
    return res;
  }
  // used by publisher & subscriber, fill the pointer of tzc_transport::vector with shared memory address
  void fillArray(long handle, ShmMessage * shmmsg) {
    if (shmmsg_)
      shmmsg_->release();

    handle_ = handle;
    shmmsg_ = shmmsg;

    void * tmp = (void *)(shmmsg_ + 1);
@{
tzc_gencpp.spec_to_fillarray(spec, msg_context, search_path, '', '    ')
}@
  }

public:
  friend class Publisher< @(cpp_class) >;
  friend class SubscriberCallbackHelper< @(cpp_class) >;

  typedef boost::shared_ptr< @(cpp_class) > Ptr;
  typedef boost::shared_ptr< @(cpp_class) const > ConstPtr;

}; // class @(cpp_class)

@# Shared pointer typedefs
typedef boost::shared_ptr< @(cpp_class) > @(cpp_class)Ptr;
typedef boost::shared_ptr< @(cpp_class) const > @(cpp_class)ConstPtr;

@# End of namespace
} // namespace @(spec.package)
} // namespace tzc_transport

@# Message Traits
namespace ros {
namespace message_traits {

@{
bool_traits = dict(IsMessage=True,
                   IsFixedSize=gencpp.is_fixed_length(spec, msg_context, search_path),
                   HasHeader=spec.has_header(),
                   )
def booltotype(b):
   return "TrueType" if b else "FalseType"
}

// BOOLTRAITS @bool_traits
// @search_path

@# TODO
// !!!!!!!!!!! @(dir(spec))
@#if spec.is_fixed_length():
@#    traits = traits.append('IsFixedSize')

@#template <class ContainerAllocator>
@#struct IsFixedSize<@(cpp_full_name) >:: @(dir(spec)) ? "TrueType" ! "FalseType") { };
@#template <class ContainerAllocator>
@#struct IsFixedSize<@(cpp_full_name) const >:: @(dir(spec)) ? "TrueType" ! "FalseType") { };

@# Binary traits

@[for k, v in bool_traits.items()]@

template <>
struct @(k)< @(cpp_full_name) >
  : @(booltotype(v)) {
};

template <>
struct @(k)< @(cpp_full_name) const>
  : @(booltotype(v)) {
};
@[end for]@

@# String traits
@[for trait_class,trait_value in [['MD5Sum', md5sum], ['DataType', spec.full_name], ['Definition', cpp_msg_definition]]]@

template <>
struct @(trait_class)< @(cpp_full_name) > {
  static const char * value() {
    return "@(trait_value)";
  }

  static const char * value(const @(cpp_full_name) &) {
    return value();
  }
@{
if trait_class == 'MD5Sum':
  iter_count = int(len(trait_value) / 16)
  for i in range(0, iter_count):
    start = i*16
    print('  static const uint64_t static_value%s = 0x%sULL;'%((i+1), trait_value[start:start+16]))
}@
};
@[end for]@

@# End of traits
} // namespace message_traits
} // namespace ros

@# Serialization
namespace ros {
namespace serialization {

  template <> struct Serializer< @(cpp_full_name)_ > {
@[if spec.parsed_fields()]@
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m) {
@[for field in spec.parsed_fields()]@
      stream.next(m.@(field.name));
@[end for]@
    }
@[else]@
    template <typename Stream, typename T> inline static void allInOne(Stream &, T) {
    }
@[end if]@

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // class @(cpp_class)_

  template <> struct Serializer< @(cpp_full_name) > {
    template <typename Stream, typename T> inline static void allInOne(Stream & stream, T m) {
      stream.next(*(@(cpp_full_name)_ *)&m);
      stream.next(*(::tzc_transport::BaseMsg *)&m);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // class @(cpp_class)

} // namespace serialization
} // namespace ros

#endif // TZC_@(spec.package.upper())_MESSAGE_@(spec.short_name.upper())_HPP

